import { promises as fs, existsSync } from 'fs'
import gql from 'graphql-tag'
import path from 'path'

export default function morphAllViews({ appName, filesViewGraphql, src }) {
  return [...filesViewGraphql]
    .map((file) => {
      let viewPath = path.relative(src, path.dirname(file))

      let files = [
        {
          file: `${file}.js`,
          content: maybeMorph({
            appName,
            file,
            src,
            viewPath,
          }),
        },
      ]

      if (path.basename(file) === 'data.graphql') {
        files.push({
          file: path.join(path.dirname(file), 'data.js'),
          content: makeDataJs({
            file,
            viewName: path.basename(viewPath),
          }),
        })
      }

      return files
    })
    .flat()
}

async function maybeMorph({ appName, file, src, viewPath }) {
  let content = await fs.readFile(file, 'utf8')

  let operationName = `${appName}__${viewPath}`.replace(/[^A-Za-z0-9_]/g, '_')
  let [, type, start] =
    content.match(/(query|subscription|mutation).+?([({])/) || []
  let typeNameRegex = new RegExp(`${type}.+?[({]`)

  content = content.replace(typeNameRegex, `${type} ${operationName}${start}`)

  try {
    // eslint-disable-next-line
    gql`
      ${content}
    `

    return `// this is an autogenerated file from ${path.relative(src, file)}
import { gql } from 'Data/Api.js'

export default gql\`
${content}
\``
  } catch (error) {
    console.error(`Failed to morph GraphQL file ${file}. Content:\n${content}`)
    console.error(error)

    return `// this is an autogenerated file from ${path.relative(src, file)}

export default null`
  }
}

async function makeDataJs({ file, viewName }) {
  let content = await fs.readFile(file, 'utf8')

  try {
    // eslint-disable-next-line
    let parsed = gql`
      ${content}
    `
    let definition = parsed.definitions[0]

    // TODO make morpher pick changes on these files as well as query.graphl
    // and remorph data.js
    let isUsingDataTransform = existsSync(
      path.join(path.dirname(file), 'useDataTransform.js')
    )
    let isUsingDataConfiguration = existsSync(
      path.join(path.dirname(file), 'useDataConfiguration.js')
    )
    // TODO sometimes we want to send a configuration value such as context: {requestPolicy: 'cache-and-network'} or pause: true,
    // even if there's no variable
    // && definition.variableDefinitions.length > 0
    let useOperation =
      definition.operation === 'query' ? 'useQuery' : 'useSubscription'
    let isQueryOperation = definition.operation === 'query'
    let field = definition.selectionSet.selections[0]
    let context = field.alias ? field.alias.value : field.name.value

    let importName = existsSync(path.join(path.dirname(file), 'logic.js'))
      ? 'Logic'
      : 'View'

    return `// This file is auto-generated. Edit query.graphql to change it.
import { DataProvider, useSetFlowToBasedOnData } from 'Data/ViewsData.js'
import { ${useOperation} } from 'Data/Api.js'
${
  isUsingDataTransform
    ? "import useDataTransform from './useDataTransform.js'"
    : ''
}
${
  isUsingDataConfiguration
    ? "import useDataConfiguration from './useDataConfiguration.js'"
    : ''
}
import query from './data.graphql.js'
import React from 'react'
import ${importName} from './${importName.toLowerCase()}.js'

export default function ${viewName}Data(props) {
${
  isUsingDataConfiguration
    ? '  let configuration = useDataConfiguration(props)'
    : ''
}
  let [{ data${isUsingDataTransform ? ': rdata' : ''}, ${
      isQueryOperation ? 'fetching, ' : ''
    }error }] = ${useOperation}({ query${
      isUsingDataConfiguration ? ', ...configuration' : ''
    } })
${isUsingDataTransform ? '  let data = useDataTransform(props, rdata)' : ''}
  useSetFlowToBasedOnData({context: '${context}', data, ${
      isQueryOperation ? 'fetching' : 'fetching: !data'
    }, error, viewPath: props.viewPath, pause: ${
      isUsingDataConfiguration ? 'configuration.pause' : 'false'
    }})

  return (
    <DataProvider
      context="${context}"
      value={data}
      viewPath={props.viewPath}
    >
      <${importName} {...props} />
    </DataProvider>
  )
}`
  } catch (error) {}
}
